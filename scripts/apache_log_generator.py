"""
Apache Log Generator

This module provides functionality to generate synthetic Apache access log
entries and write them to a file. It is designed to simulate various IP
addresses, HTTP requests, and responses for testing or development purposes.

Functions:
- generate_log_entry(): Generates a single log entry with a random IP, request,
    status code, response size, and timestamp.
- write_log_file(filename: str, num_entries: int, block_size: int): Writes
    a specified number of log entries to the given file.

Example usage:
To generate and write 100 log entries to 'access.log', you can use:
    write_log_file('access.log', 100)
"""

import os
import sys
import random
from datetime import datetime, timedelta
from typing import List

from scripts.utils.common import load_config, will_checker


# Chemin vers votre fichier de configuration
config_path = os.path.join('config', 'config.json')
config = load_config(config_path)

# List of example IP addresses, requests, and HTTP status codes
IPS = config['LOG_GENERATION_IPS']
REQUESTS = config['LOG_GENERATION_REQUESTS']
STATUS = config['LOG_GENERATION_STATUS']
MIN_SIZE = config['LOG_GENERATION_MIN_SIZE']  # Taille minimale de la réponse
MAX_SIZE = config['LOG_GENERATION_MAX_SIZE']  # Taille maximale de la réponse

# Décalage temporel maximal en secondes
MAX_TIME_OFFSET_SECONDS = config['LOG_GENERATION_MAX_TIME_OFFSET_SECONDS']
DEFAULT_FILENAME = config['LOG_GENERATION_DEFAULT_FILENAME']


def generate_log_entry(ips: List[str], requests: List[str], statuses: List[int],
                       min_size: int, max_size: int,
                       max_time_offset_seconds: int,  now: datetime) -> str:
    """
    Generates a single log entry.

    Args:
        ips (List[str]): A list of IP addresses to choose from.
        requests (List[str]): A list of HTTP requests to choose from.
        statuses (List[int]): A list of HTTP statuses to choose from.
        min_size (int): Minimum size of the response. Defaults to 100
        max_size (int): Maximum size of the response. Defaults to 5000
        max_time_offset_seconds (int): Maximum time offset in seconds
            for the log timestamp. Defaults to 86400 (24 hours).
        now (datetime): The current timestamp.

    Returns:
        str: A formatted log entry string.
    """

    assert ips, "La liste des adresses IP ne doit pas être vide."
    assert requests, "La liste des requêtes ne doit pas être vide."
    assert statuses, "La liste des statuts ne doit pas être vide."

    ip = random.choice(ips)
    time_offset = timedelta(seconds=random.randint(0, max_time_offset_seconds))
    log_time = (now - time_offset).strftime('%d/%b/%Y:%H:%M:%S %z')
    request = random.choice(requests)
    status = random.choice(statuses)
    size = random.randint(min_size, max_size)
    log_entry = f'{ip} - - [{log_time}] "{request}" {status} {size}\n'
    return log_entry

def write_log_file(filename: str, num_entries: int,
                   block_size: int=500) -> None:
    """
    Writes a specified number of log entries to a file.

    Args:
        filename (str): The name of the file to write the log entries to.
        num_entries (int): The number of log entries to generate and write.
        block_size (int): The number of log entries to accumulate before
            writing to the file (default is 500)

    This function opens the specified file in write mode and writes the
    specified number of log entries to it.
    Each log entry is generated by calling the `generate_log_entry` function.
    """
    assert isinstance(filename, str) and filename, (
        "Le nom du fichier doit être une chaîne non vide.")
    assert isinstance(num_entries, int) and num_entries > 0, (
        "Le nombre d'entrées doit être un entier positif.")
    assert isinstance(block_size, int) and block_size > 0, (
        "La taille du bloc doit être un entier positif.")

    now = datetime.now()
    log_entries = []  # Liste pour accumuler les entrées de log

    try:
        with open(filename, 'a', encoding="utf-8") as file:
            for _ in range(num_entries):
                log_entry = generate_log_entry(IPS, REQUESTS, STATUS,
                                               MIN_SIZE, MAX_SIZE,
                                               MAX_TIME_OFFSET_SECONDS, now)
                log_entries.append(log_entry)

                # check if block size is reached and write to file if so
                if len(log_entries) >= block_size:
                    file.write(''.join(log_entries))
                    log_entries = []

            if log_entries:  # write remaining entries
                file.write(''.join(log_entries))
    except IOError as e:
        print(f"Error while writing in {filename}: {e}")
    except Exception as e:
        print(f"Unexpected error occurred: {e}")


def user_input_line() -> int:
    """
    Function that asks the user for the number of lines to generate.

    Returns:
        int: The number of lines to generate.
    """
    input_lines = input("Enter the number of lines to generate (max 10,000) "
                        "(default is 1000): ")
    try:
        input_lines = int(input_lines)
        # checks if the input is too large or not an integer or negative
        if input_lines > 10000:
            print("Input is too large. Max value of 10,000 will be used.")
            input_lines = 10000
        if input_lines < 1:
            print("Input is too small. Default value of 1,000 will be used.")
            input_lines = 1000
    except ValueError:
        print("The input is not a number. Default value of 1,000 will be used.")
        input_lines = 1000
    return input_lines


def user_file_creation() -> tuple:
    """
    Function that asks the user for the filename and returns a safe version.

    Returns:
        tuple: A tuple containing the filepath and the safe filename.
    """
    decision = input("Do you want to create a new log file or use "
                     "generate_access.log ? (yes/no)").lower()
    if will_checker(decision):
        filename_input = input("Enter filename (without extension): ")
        safe_filename = os.path.basename(filename_input) + ".log"
    else:
        safe_filename = DEFAULT_FILENAME

    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)
    filepath = os.path.join(base_dir, "datas", "raw_logs", safe_filename)

    # Vérifiez si le répertoire existe, sinon créez-le
    directory = os.path.dirname(filepath)
    if not os.path.exists(directory):
        os.makedirs(directory)

    if os.path.exists(filepath):  # check if the file already exists
        overwrite_decision = input("The file already exists. Are you sure you"
                                   " want to overwrite it? (yes/no) ")
        if not will_checker(overwrite_decision):
            print("Operation cancelled.")
            # terminer le programme tout entier
            sys.exit()

    return filepath, safe_filename

def main() -> None:
    """
    Main function to run the log file generator.
    """


    filepath, safe_filename = user_file_creation()
    assert (isinstance(filepath, str) and isinstance(safe_filename, str)), (
        "Le chemin du fichier et le nom du fichier doivent être des chaînes.")


    nb_line_to_generate = user_input_line()
    assert (isinstance(nb_line_to_generate, int)  and
            10000 > nb_line_to_generate > 0), (
        "Le nombre de lignes à générer doit être un entier positif.")

    # generate and write the log file
    write_log_file(filepath, nb_line_to_generate)

    print(f"File '{safe_filename}' successfully created in "
          "the /log_analyzer/datas/raw_logs directory.")


if __name__ == "__main__":
    main()
